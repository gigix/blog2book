<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=GBK">
<title>A functional-programming view of time--透明思考</title>
<META HTTP-EQUIV="Pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache"> 
<META HTTP-EQUIV="Expires" CONTENT="0"> 
<META CONTENT="投机者的大胜利A functional-programming view of time数据即操作・丘奇代数  博客 博客动力 blog blogdriver blogger 中国" NAME="description"> 
<META NAME="keywords" CONTENT="透明思考 投机者的大胜利A functional-programming view of time数据即操作・丘奇代数 博客 博客动力 blog blogdriver blogger 中国"> 
<link href="diary.css" rel="stylesheet" type="text/css">
<script language="JavaScript" src="/jsp/js/UBB.js"></script>
<script type="text/javascript" src="/jsp/js/blog.js"></script>	
</head>
<body>
  <div id="container">
    <div id="header"><h1 class="title"><a href="index.html">透明思考</a></h1></div>
	<div id="category">	<a href="835620.html" title="上一篇">投机者的大胜利</a>- -|
		<a href="index.html">回首页</a> | <a href="catalog_2005.html">2005年索引</a>
	| - -<a href="850297.html" title="下一篇">数据即操作・丘奇代数</a></div>
 <div class="entity">
			    <h2 class="diaryTitle">A functional-programming view of time- -</h2> 
				 <p/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				 <p><h4><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_Temp_503">A functional-programming view of time</a></h4><p><a name="%_idx_4144"></a><a name="%_idx_4146"></a>Let us now return to the issues of objects and state that were raised at the beginning of this chapter and examine them in a new light. We introduced assignment and mutable objects to provide a mechanism for modular construction of programs that model systems with state. We constructed computational objects with local state variables and used assignment to modify these variables. We modeled the temporal behavior of the objects in the world by the temporal behavior of the corresponding computational objects. </p><p>Now we have seen that streams provide an alternative way to model objects with local state. We can model a changing quantity, such as the local state of some object, using a stream that represents the time history of successive states. In essence, we represent time explicitly, using streams, so that we decouple time in our simulated world from the sequence of events that take place during evaluation. Indeed, because of the presence of <tt><font face="新宋体">delay</font></tt> there may be little relation between simulated time in the model and the order of events during the evaluation. </p><p>In order to contrast these two approaches to modeling, let us reconsider the implementation of a ``withdrawal processor'' that <a name="%_idx_4148"></a>monitors the balance in a bank account. In section&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3">3.1.3</a> we implemented a simplified version of such a processor: </p><p /><p /><p><tt><a name="%_idx_4150"></a><font face="新宋体">(define&nbsp;(make-simplified-withdraw&nbsp;balance)<br />&nbsp;&nbsp;(lambda&nbsp;(amount)<br />&nbsp;&nbsp;&nbsp;&nbsp;(set!&nbsp;balance&nbsp;(-&nbsp;balance&nbsp;amount))<br />&nbsp;&nbsp;&nbsp;&nbsp;balance))<br /></font></tt></p><p><font face="新宋体"></font></p><p>Calls to <tt><font face="新宋体">make-simplified-withdraw</font></tt> produce computational objects, each with a local state variable <tt><font face="新宋体">balance</font></tt> that is decremented by successive calls to the object. The object takes an <tt><font face="新宋体">amount</font></tt> as an argument and returns the new balance. We can imagine the user of a bank account typing a sequence of inputs to such an object and observing the sequence of returned values shown on a display screen. </p><p>Alternatively, we can model a withdrawal processor as a procedure that takes as input a balance and a stream of amounts to withdraw and produces the stream of successive balances in the account: </p><p /><p /><p><tt><a name="%_idx_4152"></a><font face="新宋体">(define&nbsp;(stream-withdraw&nbsp;balance&nbsp;amount-stream)<br />&nbsp;&nbsp;(cons-stream<br />&nbsp;&nbsp;&nbsp;balance<br />&nbsp;&nbsp;&nbsp;(stream-withdraw&nbsp;(-&nbsp;balance&nbsp;(stream-car&nbsp;amount-stream))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stream-cdr&nbsp;amount-stream))))<br /></font></tt></p><p><font face="新宋体"></font></p><p><tt><font face="新宋体">Stream-withdraw</font></tt> implements a well-defined mathematical function whose output is fully determined by its input. Suppose, however, that the input <tt><font face="新宋体">amount-stream</font></tt> is the stream of successive values typed by the user and that the resulting stream of balances is displayed. Then, from the perspective of the user who is typing values and watching results, the stream process has the same behavior as the object created by <tt><font face="新宋体">make-simplified-withdraw</font></tt>. However, with the stream version, there is no assignment, no local state variable, and consequently none of the theoretical difficulties that we encountered <a name="%_idx_4154"></a>in section&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>. Yet the system has state! </p><p>This is really remarkable. Even though <tt><font face="新宋体">stream-withdraw</font></tt> implements a well-defined mathematical function whose behavior does not change, the user's perception here is one of interacting with a system that has a changing state. One way to resolve this paradox is to realize that it is the user's temporal existence that imposes state on the system. If the user could step back from the interaction and think in terms of streams of balances rather than individual transactions, the system would appear stateless.<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#footnote_Temp_504" name="call_footnote_Temp_504"><sup><small><font size="2">73</font></small></sup></a> </p><p>From the point of view of one part of a complex process, the other parts appear to change with time. They have hidden time-varying local state. If we wish to write programs that model this kind of natural decomposition in our world (as we see it from our viewpoint as a part of that world) with structures in our computer, we make computational objects that are not functional -- they must change with time. We model state with local state variables, and we model the changes of state with assignments to those variables. By doing this we make the time of execution of a computation model time in the world that we are part of, and thus we get ``objects'' in our computer. </p><p>Modeling with objects is powerful and intuitive, largely because this matches the perception of interacting with a world of which we are part. However, as we've seen repeatedly throughout this chapter, these models raise thorny problems of constraining the order of events and of synchronizing multiple processes. The possibility of avoiding these problems has stimulated the development of <a name="%_idx_4158"></a><a name="%_idx_4160"></a><em>functional programming languages</em>, which do not include any provision for assignment or mutable data. In such a language, all procedures implement well-defined mathematical functions of their arguments, whose behavior does not change. The functional approach is extremely <a name="%_idx_4162"></a><a name="%_idx_41"></a>attractive for dealing with concurrent systems.<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#footnote_Temp_505" name="call_footnote_Temp_505"><sup><small><font size="2">74</font></small></sup></a> </p><p>On the other hand, if we look closely, we can see time-related problems creeping into functional models as well. One particularly troublesome area arises when we wish to design interactive systems, especially ones that model interactions between independent entities. For instance, consider once more the implementation a banking system that permits joint bank accounts. In a conventional system using assignment and objects, we would model the fact that Peter and Paul share an account by having both Peter and Paul send their transaction requests to the same bank-account object, as we saw in section&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3">3.1.3</a>. From the stream point of view, where there are no ``objects'' <em>per se</em>, we have already indicated that a bank account can be modeled as a process that operates on a stream of transaction requests to produce a stream of responses. Accordingly, we could model the fact that Peter and Paul have a joint bank account by merging Peter's stream of transaction requests with Paul's stream of requests and feeding the result to the bank-account stream process, as shown in figure&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_fig_3.38">3.38</a>. </p><p><a name="%_fig_3.38"></a></p><p /><div align="left"><table width="100%"><tbody><tr><td><img src="http://mitpress.mit.edu/sicp/full-text/book/ch3-Z-G-60.gif" border="0" /> </td></tr></tbody><caption align="bottom"><div align="left"><b>Figure 3.38:</b>&nbsp;&nbsp;A joint bank account, modeled by merging two streams of transaction requests.</div></caption><tbody><tr><td><a name="%_idx_4176"></a></td></tr></tbody></table></div><p /><p><a name="%_idx_4178"></a>The trouble with this formulation is in the notion of <em>merge</em>. It will not do to merge the two streams by simply taking alternately one request from Peter and one request from Paul. Suppose Paul accesses the account only very rarely. We could hardly force Peter to wait for Paul to access the account before he could issue a second transaction. However such a merge is implemented, it must interleave the two transaction streams in some way that is constrained by ``real time'' as perceived by Peter and Paul, in the sense that, if Peter and Paul meet, they can agree that certain transactions were processed before the meeting, and other transactions were processed after the meeting.<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#footnote_Temp_506" name="call_footnote_Temp_506"><sup><small><font size="2">75</font></small></sup></a> This is precisely the same constraint that we had to deal with in section&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#%_sec_3.4.1">3.4.1</a>, where we found the need to introduce explicit synchronization to ensure a ``correct'' order of events in concurrent processing of objects with state. Thus, in an attempt to support the functional style, the need to merge inputs from different agents reintroduces the same problems that the functional style was meant to eliminate. </p><p>We began this chapter with the goal of building computational models whose structure matches our perception of the real world we are trying to model. We can model the world as a collection of separate, time-bound, interacting objects with state, or we can model the world as a single, timeless, stateless unity. Each view has powerful advantages, but neither view alone is completely satisfactory. A grand unification has yet to emerge.<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#footnote_Temp_507" name="call_footnote_Temp_507"><sup><small><font size="2">76</font></small></sup></a> </p><p>――――――――</p><p><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#call_footnote_Temp_504" name="footnote_Temp_504"><sup><small><font size="2">73</font></small></sup></a> Similarly in physics, when we observe a moving particle, we say that the position (state) of the particle is changing. However, from the perspective of the particle's <a name="%_idx_4156"></a>world line in space-time there is no change involved. </p><p><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#call_footnote_Temp_505" name="footnote_Temp_505"><sup><small><font size="2">74</font></small></sup></a> John Backus, the inventor of Fortran, gave high <a name="%_idx_4166"></a><a name="%_idx_4168"></a><a name="%_idx_4170"></a><a name="%_idx_4172"></a><a name="%_idx_4174"></a>visibility to functional programming when he was awarded the ACM Turing award in 1978. His acceptance speech (Backus 1978) strongly advocated the functional approach. A good overview of functional programming is given in Henderson 1980 and in Darlington, Henderson, and Turner 1982. </p><p><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#call_footnote_Temp_506" name="footnote_Temp_506"><sup><small><font size="2">75</font></small></sup></a> Observe that, for any two streams, there is in general more than one <a name="%_idx_4180"></a><a name="%_idx_4182"></a>acceptable order of interleaving. Thus, technically, ``merge'' is a relation rather than a function -- the answer is not a deterministic function of the inputs. We already mentioned (footnote&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-23.html#footnote_Temp_411">39</a>) that nondeterminism is essential when dealing with concurrency. The merge relation illustrates the same essential nondeterminism, from the functional perspective. In section&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-28.html#%_sec_4.3">4.3</a>, we will look at nondeterminism from yet another point of view. </p><p><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#call_footnote_Temp_507" name="footnote_Temp_507"><sup><small><font size="2">76</font></small></sup></a> The object model approximates the world by dividing it into separate pieces. The functional model does not modularize along object boundaries. The object model is useful when <a name="%_idx_4184"></a>the unshared state of the ``objects'' is much larger than the state that they share. An example of a place where the object viewpoint fails is <a name="%_idx_4186"></a>quantum mechanics, where thinking of things as individual particles leads to paradoxes and confusions. Unifying the object view with the functional view may have little to do with programming, but rather with fundamental epistemological issues. </p></p>				  
             <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogdriver.com/blog/postMessage.b?receiver=25249','发送短消息','width=520, height=455')">透明</a> 2005年07月27日, 星期三 09:32  </p>
				</div>
 <div class="operation"> 
    <a name="trackback"><H3>Trackback</H3></a>
      <p class="trackback">你可以使用这个链接引用该篇日志 http://publishblog.blogdriver.com/blog/tb.b?diaryID=847571
 </p>
 </div>				
<div class="operation">
     <a name="comment"><H3>回复</H3></a>
     <a name="comment$(remark.remarkID)"><H4> - 评论人：若雪 </H4></a> 
    <H5>Fri Jul 29 16:22:49 CST 2005　 
        <a href="mailto:lsybhm@126.com"><img src="http://www.blogdriver.com/template/common/img/letter.gif" width="16" height="12" border="0" align="absmiddle" class="imgStyle" alt="作者邮箱"></a>　
            <a href="HTTP://spaces.msn.com/ruoxue0" target="_blank"><img src="http://www.blogdriver.com/template/common/img/blog_2.gif" width="16" height="14" border="0" align="texttop"  class="imgStyle" alt="作者Blog"></a>
	</H5> 
    <BR/>
    <P class="comment">一堂言<br>       凡事必有其自身规律，痴心于某件事定有收获。<br>       交友如读书有选择读，编程者必知其来龙去脉。<br>
      <br>
    </P>
     <a name="comment$(remark.remarkID)"><H4> - 评论人：果壳Nutshell </H4></a> 
    <H5>Wed Jul 27 17:43:25 CST 2005　 
            <a href="HTTP://" target="_blank"><img src="http://www.blogdriver.com/template/common/img/blog_2.gif" width="16" height="14" border="0" align="texttop"  class="imgStyle" alt="作者Blog"></a>
	</H5> 
    <BR/>
    <P class="comment">盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也。<br>
      <br>
    </P>
 </div>
  <div class="operation"> 
    <table width="700" border="0" cellpadding="0" cellspacing="0" class="comment">
      <form id="replyForm" method="POST">
        <input type="hidden" name="blogID" value="18254">
        <input type="hidden" name="diaryID" value="847571">
        <input type="hidden" name="blogDomino" value="gigix">
<script>
if(getCookie('userID') == null){        
document.write('<tr><td width="70">发布人：</td>');
document.write('<td width="150"> <input name="remark.authorNameFUI" type="text" size="20" class="inputStyle" maxlength="20"></td>');
document.write('<td width="70">邮箱：</td>');
document.write('<td width="435"> <input name="remark.authorEmail" type="text" size="20" class="inputStyle" maxlength="40"></td>');
document.write('</tr><tr><td>主　页：</td>');
document.write('<td colspan="3"> <input name="remark.authorURL" type="text" class="inputStyle" value="HTTP://" size="63" maxlength="40"></td></tr>');
}else{
document.write('<input type="hidden" name="remark.authorNameFUI" value="Blogdriver">');
}
</script>        
        <tr align="left"> 
          <td colspan="4">评论内容：<br/> <textarea name="remark.remarkFUI" id="remark" cols="60" rows="8" class="textStyle" >
          </textarea> 
          </td> 
        </tr>
        <tr align="left"> 
          <td colspan="4"> 　　　　　　 　　　　　　 
            <input type="button" value="提交" onClick="reply()" >
            　 
            <input type="reset" value="重置" > </td>
        </tr>
      </form>
    </table>
  </div>
</div>	
<script type="text/javascript" src="http://gigix.blogdriver/gigix/extend3.js"></script> 
<div id="footer"><a href="http://www.blogdriver.com/jsp/reg/register.jsp"><img class="logo" src="http://www.blogdriver.com/template/common/img/logo3.gif" border="0"></a><a href="http://www.blogdriver.com/">2003-2004 BLOGDRIVER.COM All rights reserved</a></div>
</body>
</html>
